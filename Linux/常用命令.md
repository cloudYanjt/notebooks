ps

kill

top

mount

df

du

cat

sort

grep

gzip

tar

进程列表 （;）

后台模式\<command\> &

jobs jobs命令可以显示出当前运行在后台模式中的所有用户的进程（作业）

coproc 它在后台生成一个子shell，并在这个子shell中执行命令。扩展语法  coproc My_Job { sleep 10; } 这里要注意的是，扩展语法写起来有点麻烦。必须确保在第一个花括号（{）和命令名之间有一个空格。还必须保证命令以分号（;）结尾。另外，分号和闭花括号（}）之间也得有一个空格。

命令type -a显示出了每个命令的两种实现。which命令只显示出了外部命令文件

history 要查看最近用过的命令列表，可以输入不带选项的history命令
命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。这里要注意的是，
bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中
history -a 实现强制写入.bash_history中

!! 唤回最近使用的一条命令并执行，!序号 唤回history对应序号的命令并执行

要查看全局变量，可以使用env或printenv命令
要显示个别环境变量的值，可以使用printenv命令(printenv HOME)或echo $HOME，但是无法使用env命令(~~env HOME~~)
set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量
以及用户定义变量。



创建局部环境变量 my_variable=Hello，my_variable="Hello World"，不要有空格，如果要给变量赋一个含有空格的字符串值，必须用引号来界定字符串的首和尾。

设置全局环境变量  my_variable="I am Global now"        export my_variable  先创建一个局部环境变量，然后再把它导出到全局环境中。这个过程通过export命令来完成，变量名前面不需要加$

删除环境变量 unset my_variable 在unset命令中引用环境变量时，记住不要使用$

在涉及环境变量名时，什么时候该使用$，什么时候不该使用$，实在让人摸不着头脑。记住一点就行了：如果要用到变量，使用$；如果要操作变量，不使用$。这条规则的一个例外就是使用printenv显示某个变量的值